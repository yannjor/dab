var _ServerSentEvent_data, _ServerSentEvent_id, _ServerSentEvent_type, _SSEStreamTarget_instances, _SSEStreamTarget_closed, _SSEStreamTarget_context, _SSEStreamTarget_controller, _SSEStreamTarget_keepAliveId, _SSEStreamTarget_error, _SSEStreamTarget_push;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
// Copyright 2018-2022 the oak authors. All rights reserved. MIT license.
import * as dntShim from "./_dnt.shims.js";
import { assert } from "./util.js";
const encoder = new TextEncoder();
const DEFAULT_KEEP_ALIVE_INTERVAL = 30000;
class CloseEvent extends Event {
    constructor(eventInit) {
        super("close", eventInit);
    }
}
/** An event which contains information which will be sent to the remote
 * connection and be made available in an `EventSource` as an event. A server
 * creates new events and dispatches them on the target which will then be
 * sent to a client.
 *
 * See more about Server-sent events on [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events)
 *
 * ### Example
 *
 * ```ts
 * import { Application, ServerSentEvent } from "https://deno.land/x/oak/mod.ts";
 *
 * const app = new Application();
 *
 * app.use((ctx) => {
 *   const target = ctx.sendEvents();
 *   const evt = new ServerSentEvent(
 *     "message",
 *     { hello: "world" },
 *     { id: 1 },
 *   );
 *   target.dispatchEvent(evt);
 * });
 * ```
 */
export class ServerSentEvent extends Event {
    /**
     * @param type the event type that will be available on the client. The type
     *             of `"message"` will be handled specifically as a message
     *             server-side event.
     * @param data  arbitrary data to send to the client, data this is a string
     *              will be sent unmodified, otherwise `JSON.parse()` will be used
     *              to serialize the value
     * @param eventInit initialization options for the event
     */
    constructor(type, data, eventInit = {}) {
        super(type, eventInit);
        _ServerSentEvent_data.set(this, void 0);
        _ServerSentEvent_id.set(this, void 0);
        _ServerSentEvent_type.set(this, void 0);
        const { replacer, space } = eventInit;
        __classPrivateFieldSet(this, _ServerSentEvent_type, type, "f");
        try {
            __classPrivateFieldSet(this, _ServerSentEvent_data, typeof data === "string"
                ? data
                : JSON.stringify(data, replacer, space), "f");
        }
        catch (e) {
            assert(e instanceof Error);
            throw new TypeError(`data could not be coerced into a serialized string.\n  ${e.message}`);
        }
        const { id } = eventInit;
        __classPrivateFieldSet(this, _ServerSentEvent_id, id, "f");
    }
    /** The data associated with the event, which will be sent to the client and
     * be made available in the `EventSource`. */
    get data() {
        return __classPrivateFieldGet(this, _ServerSentEvent_data, "f");
    }
    /** The optional ID associated with the event that will be sent to the client
     * and be made available in the `EventSource`. */
    get id() {
        return __classPrivateFieldGet(this, _ServerSentEvent_id, "f");
    }
    toString() {
        const data = `data: ${__classPrivateFieldGet(this, _ServerSentEvent_data, "f").split("\n").join("\ndata: ")}\n`;
        return `${__classPrivateFieldGet(this, _ServerSentEvent_type, "f") === "__message" ? "" : `event: ${__classPrivateFieldGet(this, _ServerSentEvent_type, "f")}\n`}${__classPrivateFieldGet(this, _ServerSentEvent_id, "f") ? `id: ${String(__classPrivateFieldGet(this, _ServerSentEvent_id, "f"))}\n` : ""}${data}\n`;
    }
}
_ServerSentEvent_data = new WeakMap(), _ServerSentEvent_id = new WeakMap(), _ServerSentEvent_type = new WeakMap();
const RESPONSE_HEADERS = [
    ["Connection", "Keep-Alive"],
    ["Content-Type", "text/event-stream"],
    ["Cache-Control", "no-cache"],
    ["Keep-Alive", `timeout=${Number.MAX_SAFE_INTEGER}`],
];
export class SSEStreamTarget extends EventTarget {
    constructor(context, { headers, keepAlive = false } = {}) {
        super();
        _SSEStreamTarget_instances.add(this);
        _SSEStreamTarget_closed.set(this, false);
        _SSEStreamTarget_context.set(this, void 0);
        _SSEStreamTarget_controller.set(this, void 0);
        // we are ignoring any here, because when exporting to npn/Node.js, the timer
        // handle isn't a number.
        // deno-lint-ignore no-explicit-any
        _SSEStreamTarget_keepAliveId.set(this, void 0);
        __classPrivateFieldSet(this, _SSEStreamTarget_context, context, "f");
        context.response.body = new dntShim.ReadableStream({
            start: (controller) => {
                __classPrivateFieldSet(this, _SSEStreamTarget_controller, controller, "f");
            },
            cancel: (error) => {
                // connections closing are considered "normal" for SSE events and just
                // mean the far side has closed.
                if (error instanceof Error && error.message.includes("connection closed")) {
                    this.close();
                }
                else {
                    __classPrivateFieldGet(this, _SSEStreamTarget_instances, "m", _SSEStreamTarget_error).call(this, error);
                }
            },
        });
        if (headers) {
            for (const [key, value] of headers) {
                context.response.headers.set(key, value);
            }
        }
        for (const [key, value] of RESPONSE_HEADERS) {
            context.response.headers.set(key, value);
        }
        this.addEventListener("close", () => {
            __classPrivateFieldSet(this, _SSEStreamTarget_closed, true, "f");
            if (__classPrivateFieldGet(this, _SSEStreamTarget_keepAliveId, "f") != null) {
                clearInterval(__classPrivateFieldGet(this, _SSEStreamTarget_keepAliveId, "f"));
                __classPrivateFieldSet(this, _SSEStreamTarget_keepAliveId, undefined, "f");
            }
            if (__classPrivateFieldGet(this, _SSEStreamTarget_controller, "f")) {
                try {
                    __classPrivateFieldGet(this, _SSEStreamTarget_controller, "f").close();
                }
                catch {
                    // we ignore any errors here, as it is likely that the controller
                    // is already closed
                }
            }
        });
        if (keepAlive) {
            const interval = typeof keepAlive === "number"
                ? keepAlive
                : DEFAULT_KEEP_ALIVE_INTERVAL;
            __classPrivateFieldSet(this, _SSEStreamTarget_keepAliveId, setInterval(() => {
                this.dispatchComment("keep-alive comment");
            }, interval), "f");
        }
    }
    get closed() {
        return __classPrivateFieldGet(this, _SSEStreamTarget_closed, "f");
    }
    close() {
        this.dispatchEvent(new CloseEvent({ cancelable: false }));
        return Promise.resolve();
    }
    dispatchComment(comment) {
        __classPrivateFieldGet(this, _SSEStreamTarget_instances, "m", _SSEStreamTarget_push).call(this, `: ${comment.split("\n").join("\n: ")}\n\n`);
        return true;
    }
    // deno-lint-ignore no-explicit-any
    dispatchMessage(data) {
        const event = new ServerSentEvent("__message", data);
        return this.dispatchEvent(event);
    }
    dispatchEvent(event) {
        const dispatched = super.dispatchEvent(event);
        if (dispatched && event instanceof ServerSentEvent) {
            __classPrivateFieldGet(this, _SSEStreamTarget_instances, "m", _SSEStreamTarget_push).call(this, String(event));
        }
        return dispatched;
    }
    [(_SSEStreamTarget_closed = new WeakMap(), _SSEStreamTarget_context = new WeakMap(), _SSEStreamTarget_controller = new WeakMap(), _SSEStreamTarget_keepAliveId = new WeakMap(), _SSEStreamTarget_instances = new WeakSet(), _SSEStreamTarget_error = function _SSEStreamTarget_error(error) {
        console.log("error", error);
        this.dispatchEvent(new CloseEvent({ cancelable: false }));
        const errorEvent = new dntShim.ErrorEvent("error", { error });
        this.dispatchEvent(errorEvent);
        __classPrivateFieldGet(this, _SSEStreamTarget_context, "f").app.dispatchEvent(errorEvent);
    }, _SSEStreamTarget_push = function _SSEStreamTarget_push(payload) {
        if (!__classPrivateFieldGet(this, _SSEStreamTarget_controller, "f")) {
            __classPrivateFieldGet(this, _SSEStreamTarget_instances, "m", _SSEStreamTarget_error).call(this, new Error("The controller has not been set."));
            return;
        }
        if (__classPrivateFieldGet(this, _SSEStreamTarget_closed, "f")) {
            return;
        }
        __classPrivateFieldGet(this, _SSEStreamTarget_controller, "f").enqueue(encoder.encode(payload));
    }, Symbol.for("Deno.customInspect"))](inspect) {
        return `${this.constructor.name} ${inspect({ "#closed": __classPrivateFieldGet(this, _SSEStreamTarget_closed, "f"), "#context": __classPrivateFieldGet(this, _SSEStreamTarget_context, "f") })}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, 
    // deno-lint-ignore no-explicit-any
    options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1,
        });
        return `${options.stylize(this.constructor.name, "special")} ${inspect({ "#closed": __classPrivateFieldGet(this, _SSEStreamTarget_closed, "f"), "#context": __classPrivateFieldGet(this, _SSEStreamTarget_context, "f") }, newOptions)}`;
    }
}
