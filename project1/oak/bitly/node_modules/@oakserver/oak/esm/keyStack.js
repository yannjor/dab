// Copyright 2018-2022 the oak authors. All rights reserved. MIT license.
var _KeyStack_instances, _KeyStack_cryptoKeys, _KeyStack_keys, _KeyStack_toCryptoKey;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
// This was inspired by [keygrip](https://github.com/crypto-utils/keygrip/)
// which allows signing of data (cookies) to prevent tampering, but also allows
// for easy key rotation without needing to resign the data.
import * as dntShim from "./_dnt.shims.js";
import { timingSafeEqual } from "./deps.js";
import { encodeBase64Safe, importKey, sign } from "./util.js";
/** Compare two strings, Uint8Arrays, ArrayBuffers, or arrays of numbers in a
 * way that avoids timing based attacks on the comparisons on the values.
 *
 * The function will return `true` if the values match, or `false`, if they
 * do not match.
 *
 * This was inspired by https://github.com/suryagh/tsscmp which provides a
 * timing safe string comparison to avoid timing attacks as described in
 * https://codahale.com/a-lesson-in-timing-attacks/.
 */
async function compare(a, b) {
    const key = new Uint8Array(32);
    dntShim.dntGlobalThis.crypto.getRandomValues(key);
    const cryptoKey = await importKey(key);
    const ah = await sign(a, cryptoKey);
    const bh = await sign(b, cryptoKey);
    return timingSafeEqual(ah, bh);
}
export class KeyStack {
    /** A class which accepts an array of keys that are used to sign and verify
     * data and allows easy key rotation without invalidation of previously signed
     * data.
     *
     * @param keys An array of keys, of which the index 0 will be used to sign
     *             data, but verification can happen against any key.
     */
    constructor(keys) {
        _KeyStack_instances.add(this);
        _KeyStack_cryptoKeys.set(this, new Map());
        _KeyStack_keys.set(this, void 0);
        if (!(0 in keys)) {
            throw new TypeError("keys must contain at least one value");
        }
        __classPrivateFieldSet(this, _KeyStack_keys, keys, "f");
    }
    get length() {
        return __classPrivateFieldGet(this, _KeyStack_keys, "f").length;
    }
    /** Take `data` and return a SHA256 HMAC digest that uses the current 0 index
     * of the `keys` passed to the constructor.  This digest is in the form of a
     * URL safe base64 encoded string. */
    async sign(data) {
        const key = await __classPrivateFieldGet(this, _KeyStack_instances, "m", _KeyStack_toCryptoKey).call(this, __classPrivateFieldGet(this, _KeyStack_keys, "f")[0]);
        return encodeBase64Safe(await sign(data, key));
    }
    /** Given `data` and a `digest`, verify that one of the `keys` provided the
     * constructor was used to generate the `digest`.  Returns `true` if one of
     * the keys was used, otherwise `false`. */
    async verify(data, digest) {
        return (await this.indexOf(data, digest)) > -1;
    }
    /** Given `data` and a `digest`, return the current index of the key in the
     * `keys` passed the constructor that was used to generate the digest.  If no
     * key can be found, the method returns `-1`. */
    async indexOf(data, digest) {
        for (let i = 0; i < __classPrivateFieldGet(this, _KeyStack_keys, "f").length; i++) {
            const cryptoKey = await __classPrivateFieldGet(this, _KeyStack_instances, "m", _KeyStack_toCryptoKey).call(this, __classPrivateFieldGet(this, _KeyStack_keys, "f")[i]);
            if (await compare(digest, encodeBase64Safe(await sign(data, cryptoKey)))) {
                return i;
            }
        }
        return -1;
    }
    [(_KeyStack_cryptoKeys = new WeakMap(), _KeyStack_keys = new WeakMap(), _KeyStack_instances = new WeakSet(), _KeyStack_toCryptoKey = async function _KeyStack_toCryptoKey(key) {
        if (!__classPrivateFieldGet(this, _KeyStack_cryptoKeys, "f").has(key)) {
            __classPrivateFieldGet(this, _KeyStack_cryptoKeys, "f").set(key, await importKey(key));
        }
        return __classPrivateFieldGet(this, _KeyStack_cryptoKeys, "f").get(key);
    }, Symbol.for("Deno.customInspect"))](inspect) {
        const { length } = this;
        return `${this.constructor.name} ${inspect({ length })}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, 
    // deno-lint-ignore no-explicit-any
    options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1,
        });
        const { length } = this;
        return `${options.stylize(this.constructor.name, "special")} ${inspect({ length }, newOptions)}`;
    }
}
