"use strict";
// Copyright 2018-2022 the oak authors. All rights reserved. MIT license.
var _Context_socket, _Context_sse;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Context = void 0;
const tslib_1 = require("tslib");
const cookies_js_1 = require("./cookies.js");
const deps_js_1 = require("./deps.js");
const request_js_1 = require("./request.js");
const response_js_1 = require("./response.js");
const send_js_1 = require("./send.js");
const server_sent_event_js_1 = require("./server_sent_event.js");
/** Provides context about the current request and response to middleware
 * functions, and the current instance being processed is the first argument
 * provided a {@linkcode Middleware} function.
 *
 * _Typically this is only used as a type annotation and shouldn't be
 * constructed directly._
 *
 * ### Example
 *
 * ```ts
 * import { Application, Context } from "https://deno.land/x/oak/mod.ts";
 *
 * const app = new Application();
 *
 * app.use((ctx) => {
 *   // information about the request is here:
 *   ctx.request;
 *   // information about the response is here:
 *   ctx.response;
 *   // the cookie store is here:
 *   ctx.cookies;
 * });
 *
 * // Needs a type annotation because it cannot be inferred.
 * function mw(ctx: Context) {
 *   // process here...
 * }
 *
 * app.use(mw);
 * ```
 *
 * @template S the state which extends the application state (`AS`)
 * @template AS the type of the state derived from the application
 */
class Context {
    constructor(app, serverRequest, state, secure = false) {
        _Context_socket.set(this, void 0);
        _Context_sse.set(this, void 0);
        /** A reference to the current application. */
        Object.defineProperty(this, "app", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** An object which allows access to cookies, mediating both the request and
         * response. */
        Object.defineProperty(this, "cookies", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** Determines if the request should be responded to.  If `false` when the
         * middleware completes processing, the response will not be sent back to the
         * requestor.  Typically this is used if the middleware will take over low
         * level processing of requests and responses, for example if using web
         * sockets.  This automatically gets set to `false` when the context is
         * upgraded to a web socket via the `.upgrade()` method.
         *
         * The default is `true`. */
        Object.defineProperty(this, "respond", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** An object which contains information about the current request. */
        Object.defineProperty(this, "request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** An object which contains information about the response that will be sent
         * when the middleware finishes processing. */
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        /** The object to pass state to front-end views.  This can be typed by
         * supplying the generic state argument when creating a new app.  For
         * example:
         *
         * ```ts
         * const app = new Application<{ foo: string }>();
         * ```
         *
         * Or can be contextually inferred based on setting an initial state object:
         *
         * ```ts
         * const app = new Application({ state: { foo: "bar" } });
         * ```
         *
         * On each request/response cycle, the context's state is cloned from the
         * application state. This means changes to the context's `.state` will be
         * dropped when the request drops, but "defaults" can be applied to the
         * application's state.  Changes to the application's state though won't be
         * reflected until the next request in the context's state.
         */
        Object.defineProperty(this, "state", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.app = app;
        this.state = state;
        this.request = new request_js_1.Request(serverRequest, app.proxy, secure);
        this.respond = true;
        this.response = new response_js_1.Response(this.request);
        this.cookies = new cookies_js_1.Cookies(this.request, this.response, {
            keys: this.app.keys,
            secure: this.request.secure,
        });
    }
    /** Is `true` if the current connection is upgradeable to a web socket.
     * Otherwise the value is `false`.  Use `.upgrade()` to upgrade the connection
     * and return the web socket. */
    get isUpgradable() {
        const upgrade = this.request.headers.get("upgrade");
        if (!upgrade || upgrade.toLowerCase() !== "websocket") {
            return false;
        }
        const secKey = this.request.headers.get("sec-websocket-key");
        return typeof secKey === "string" && secKey != "";
    }
    /** If the the current context has been upgraded, then this will be set to
     * with the current web socket, otherwise it is `undefined`. */
    get socket() {
        return tslib_1.__classPrivateFieldGet(this, _Context_socket, "f");
    }
    /** Asserts the condition and if the condition fails, creates an HTTP error
     * with the provided status (which defaults to `500`).  The error status by
     * default will be set on the `.response.status`.
     *
     * Because of limitation of TypeScript, any assertion type function requires
     * specific type annotations, so the {@linkcode Context} type should be used
     * even if it can be inferred from the context.
     *
     * ### Example
     *
     * ```ts
     * import { Context, Status } from "https://deno.land/x/oak/mod.ts";
     *
     * export function mw(ctx: Context) {
     *   const body = ctx.request.body();
     *   ctx.assert(body.type === "json", Status.NotAcceptable);
     *   // process the body and send a response...
     * }
     * ```
     */
    assert(
    // deno-lint-ignore no-explicit-any
    condition, errorStatus = 500, message, props) {
        if (condition) {
            return;
        }
        const err = (0, deps_js_1.createHttpError)(errorStatus, message);
        if (props) {
            Object.assign(err, props);
        }
        throw err;
    }
    /** Asynchronously fulfill a response with a file from the local file
     * system.
     *
     * If the `options.path` is not supplied, the file to be sent will default
     * to this `.request.url.pathname`.
     *
     * Requires Deno read permission. */
    send(options) {
        const { path = this.request.url.pathname, ...sendOptions } = options;
        return (0, send_js_1.send)(this, path, sendOptions);
    }
    /** Convert the connection to stream events, returning an event target for
     * sending server sent events.  Events dispatched on the returned target will
     * be sent to the client and be available in the client's `EventSource` that
     * initiated the connection.
     *
     * This will set `.respond` to `false`. */
    sendEvents(options) {
        if (!tslib_1.__classPrivateFieldGet(this, _Context_sse, "f")) {
            tslib_1.__classPrivateFieldSet(this, _Context_sse, new server_sent_event_js_1.SSEStreamTarget(this, options), "f");
        }
        return tslib_1.__classPrivateFieldGet(this, _Context_sse, "f");
    }
    /** Create and throw an HTTP Error, which can be used to pass status
     * information which can be caught by other middleware to send more
     * meaningful error messages back to the client.  The passed error status will
     * be set on the `.response.status` by default as well.
     */
    throw(errorStatus, message, props) {
        const err = (0, deps_js_1.createHttpError)(errorStatus, message);
        if (props) {
            Object.assign(err, props);
        }
        throw err;
    }
    /** Take the current request and upgrade it to a web socket, resolving with
     * the a web standard `WebSocket` object. This will set `.respond` to
     * `false`.  If the socket cannot be upgraded, this method will throw. */
    upgrade(options) {
        if (tslib_1.__classPrivateFieldGet(this, _Context_socket, "f")) {
            return tslib_1.__classPrivateFieldGet(this, _Context_socket, "f");
        }
        if (!this.request.originalRequest.upgrade) {
            throw new TypeError("Web socket upgrades not currently supported for this type of server.");
        }
        tslib_1.__classPrivateFieldSet(this, _Context_socket, this.request.originalRequest.upgrade(options), "f");
        this.respond = false;
        return tslib_1.__classPrivateFieldGet(this, _Context_socket, "f");
    }
    [(_Context_socket = new WeakMap(), _Context_sse = new WeakMap(), Symbol.for("Deno.customInspect"))](inspect) {
        const { app, cookies, isUpgradable, respond, request, response, socket, state, } = this;
        return `${this.constructor.name} ${inspect({
            app,
            cookies,
            isUpgradable,
            respond,
            request,
            response,
            socket,
            state,
        })}`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, 
    // deno-lint-ignore no-explicit-any
    options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1,
        });
        const { app, cookies, isUpgradable, respond, request, response, socket, state, } = this;
        return `${options.stylize(this.constructor.name, "special")} ${inspect({
            app,
            cookies,
            isUpgradable,
            respond,
            request,
            response,
            socket,
            state,
        }, newOptions)}`;
    }
}
exports.Context = Context;
