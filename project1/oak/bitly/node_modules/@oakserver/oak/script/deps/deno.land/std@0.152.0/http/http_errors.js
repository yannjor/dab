"use strict";
// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.
var _HttpError_status, _HttpError_expose, _HttpError_headers;
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHttpError = exports.createHttpError = exports.errors = exports.HttpError = void 0;
const tslib_1 = require("tslib");
/** A collection of HTTP errors and utilities.
 *
 * The export {@linkcode errors} contains an individual class that extends
 * {@linkcode HttpError} which makes handling HTTP errors in a structured way.
 *
 * The function {@linkcode createHttpError} provides a way to create instances
 * of errors in a factory pattern.
 *
 * The function {@linkcode isHttpError} is a type guard that will narrow a value
 * to an `HttpError` instance.
 *
 * ### Examples
 *
 * ```ts
 * import { errors, isHttpError } from "https://deno.land/std@$STD_VERSION/http/http_errors.ts";
 *
 * try {
 *   throw new errors.NotFound();
 * } catch (e) {
 *   if (isHttpError(e)) {
 *     const response = new Response(e.message, { status: e.status });
 *   } else {
 *     throw e;
 *   }
 * }
 * ```
 *
 * ```ts
 * import { createHttpError } from "https://deno.land/std@$STD_VERSION/http/http_errors.ts";
 * import { Status } from "https://deno.land/std@$STD_VERSION/http/http_status.ts";
 *
 * try {
 *   throw createHttpError(
 *     Status.BadRequest,
 *     "The request was bad.",
 *     { expose: false }
 *   );
 * } catch (e) {
 *   // handle errors
 * }
 * ```
 *
 * @module
 */
const dntShim = tslib_1.__importStar(require("../../../../_dnt.shims.js"));
const http_status_js_1 = require("./http_status.js");
const ERROR_STATUS_MAP = {
    "BadRequest": 400,
    "Unauthorized": 401,
    "PaymentRequired": 402,
    "Forbidden": 403,
    "NotFound": 404,
    "MethodNotAllowed": 405,
    "NotAcceptable": 406,
    "ProxyAuthRequired": 407,
    "RequestTimeout": 408,
    "Conflict": 409,
    "Gone": 410,
    "LengthRequired": 411,
    "PreconditionFailed": 412,
    "RequestEntityTooLarge": 413,
    "RequestURITooLong": 414,
    "UnsupportedMediaType": 415,
    "RequestedRangeNotSatisfiable": 416,
    "ExpectationFailed": 417,
    "Teapot": 418,
    "MisdirectedRequest": 421,
    "UnprocessableEntity": 422,
    "Locked": 423,
    "FailedDependency": 424,
    "UpgradeRequired": 426,
    "PreconditionRequired": 428,
    "TooManyRequests": 429,
    "RequestHeaderFieldsTooLarge": 431,
    "UnavailableForLegalReasons": 451,
    "InternalServerError": 500,
    "NotImplemented": 501,
    "BadGateway": 502,
    "ServiceUnavailable": 503,
    "GatewayTimeout": 504,
    "HTTPVersionNotSupported": 505,
    "VariantAlsoNegotiates": 506,
    "InsufficientStorage": 507,
    "LoopDetected": 508,
    "NotExtended": 510,
    "NetworkAuthenticationRequired": 511,
};
/** The base class that all derivative HTTP extend, providing a `status` and an
 * `expose` property. */
class HttpError extends Error {
    constructor(message = "Http Error", options) {
        super(message, options);
        _HttpError_status.set(this, http_status_js_1.Status.InternalServerError);
        _HttpError_expose.set(this, void 0);
        _HttpError_headers.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _HttpError_expose, options?.expose === undefined
            ? (0, http_status_js_1.isClientErrorStatus)(this.status)
            : options.expose, "f");
        if (options?.headers) {
            tslib_1.__classPrivateFieldSet(this, _HttpError_headers, new dntShim.Headers(options.headers), "f");
        }
    }
    /** A flag to indicate if the internals of the error, like the stack, should
     * be exposed to a client, or if they are "private" and should not be leaked.
     * By default, all client errors are `true` and all server errors are
     * `false`. */
    get expose() {
        return tslib_1.__classPrivateFieldGet(this, _HttpError_expose, "f");
    }
    /** The optional headers object that is set on the error. */
    get headers() {
        return tslib_1.__classPrivateFieldGet(this, _HttpError_headers, "f");
    }
    /** The error status that is set on the error. */
    get status() {
        return tslib_1.__classPrivateFieldGet(this, _HttpError_status, "f");
    }
}
exports.HttpError = HttpError;
_HttpError_status = new WeakMap(), _HttpError_expose = new WeakMap(), _HttpError_headers = new WeakMap();
function createHttpErrorConstructor(status) {
    const name = `${http_status_js_1.Status[status]}Error`;
    const ErrorCtor = class extends HttpError {
        constructor(message = http_status_js_1.STATUS_TEXT[status], options) {
            super(message, options);
            Object.defineProperty(this, "name", {
                configurable: true,
                enumerable: false,
                value: name,
                writable: true,
            });
        }
        get status() {
            return status;
        }
    };
    return ErrorCtor;
}
/** A map of HttpErrors that are unique instances for each HTTP error status
 * code.
 *
 * ### Example
 *
 * ```ts
 * import { errors } from "https://deno.land/std@$STD_VERSION/http/http_errors.ts";
 *
 * throw new errors.InternalServerError("Ooops!");
 * ```
 */
exports.errors = {};
for (const [key, value] of Object.entries(ERROR_STATUS_MAP)) {
    exports.errors[key] = createHttpErrorConstructor(value);
}
/** Create an instance of an HttpError based on the status code provided. */
function createHttpError(status = http_status_js_1.Status.InternalServerError, message, options) {
    return new exports.errors[http_status_js_1.Status[status]](message, options);
}
exports.createHttpError = createHttpError;
/** A type guard that determines if the value is an HttpError or not. */
function isHttpError(value) {
    return value instanceof HttpError;
}
exports.isHttpError = isHttpError;
