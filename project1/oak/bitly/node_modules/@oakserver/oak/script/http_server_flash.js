"use strict";
var _FlashServer_app, _FlashServer_closed, _FlashServer_controller, _FlashServer_abortController, _FlashServer_options, _FlashServer_servePromise, _FlashServer_stream;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlashServer = exports.hasFlash = void 0;
const tslib_1 = require("tslib");
// Copyright 2018-2022 the oak authors. All rights reserved. MIT license.
const dntShim = tslib_1.__importStar(require("./_dnt.shims.js"));
const deps_js_1 = require("./deps.js");
const http_request_js_1 = require("./http_request.js");
const util_js_1 = require("./util.js");
const serve = "serve" in dntShim.Deno
    // deno-lint-ignore no-explicit-any
    ? dntShim.Deno.serve.bind(dntShim.Deno)
    : undefined;
const serveTls = "serveTls" in dntShim.Deno
    // deno-lint-ignore no-explicit-any
    ? dntShim.Deno.serveTls.bind(dntShim.Deno)
    : undefined;
function isServeTlsInit(value) {
    return "cert" in value && "key" in value;
}
/** A function that determines if the current environment supports Deno flash.*/
function hasFlash() {
    // @ts-expect-error they might not actually be defined!
    return !!(serve && serveTls);
}
exports.hasFlash = hasFlash;
/** A server abstraction which manages requests from Deno's flash server.
 *
 * You can pass the class as the `server` property when constructing a new
 * application to force the application to use Deno's flash server.
 */
class FlashServer {
    // deno-lint-ignore no-explicit-any
    constructor(app, options) {
        // deno-lint-ignore no-explicit-any
        _FlashServer_app.set(this, void 0);
        _FlashServer_closed.set(this, false);
        _FlashServer_controller.set(this, void 0);
        _FlashServer_abortController.set(this, new AbortController());
        _FlashServer_options.set(this, void 0);
        _FlashServer_servePromise.set(this, void 0);
        _FlashServer_stream.set(this, void 0);
        if (!serve || !serveTls) {
            throw new Error("The flash bindings for serving HTTP are not available.");
        }
        tslib_1.__classPrivateFieldSet(this, _FlashServer_app, app, "f");
        tslib_1.__classPrivateFieldSet(this, _FlashServer_options, options, "f");
    }
    async close() {
        if (tslib_1.__classPrivateFieldGet(this, _FlashServer_closed, "f")) {
            return;
        }
        tslib_1.__classPrivateFieldSet(this, _FlashServer_closed, true, "f");
        try {
            tslib_1.__classPrivateFieldGet(this, _FlashServer_controller, "f")?.close();
            tslib_1.__classPrivateFieldSet(this, _FlashServer_controller, undefined, "f");
            tslib_1.__classPrivateFieldSet(this, _FlashServer_stream, undefined, "f");
            tslib_1.__classPrivateFieldGet(this, _FlashServer_abortController, "f").abort();
            if (tslib_1.__classPrivateFieldGet(this, _FlashServer_servePromise, "f")) {
                await tslib_1.__classPrivateFieldGet(this, _FlashServer_servePromise, "f");
                tslib_1.__classPrivateFieldSet(this, _FlashServer_servePromise, undefined, "f");
            }
        }
        catch {
            // just swallow here
        }
    }
    listen() {
        const p = (0, deps_js_1.deferred)();
        const start = (controller) => {
            tslib_1.__classPrivateFieldSet(this, _FlashServer_controller, controller, "f");
            const options = {
                ...tslib_1.__classPrivateFieldGet(this, _FlashServer_options, "f"),
                signal: tslib_1.__classPrivateFieldGet(this, _FlashServer_abortController, "f").signal,
                onListen: (addr) => p.resolve({ addr }),
                onError: (error) => {
                    tslib_1.__classPrivateFieldGet(this, _FlashServer_app, "f").dispatchEvent(new dntShim.ErrorEvent("error", { error }));
                    return new dntShim.Response("Internal server error", {
                        status: deps_js_1.Status.InternalServerError,
                        statusText: deps_js_1.STATUS_TEXT[deps_js_1.Status.InternalServerError],
                    });
                },
            };
            const handler = (request) => {
                const resolve = (0, deps_js_1.deferred)();
                const flashRequest = new http_request_js_1.HttpRequest(request, resolve);
                controller.enqueue(flashRequest);
                return resolve;
            };
            if (isServeTlsInit(options)) {
                tslib_1.__classPrivateFieldSet(this, _FlashServer_servePromise, serveTls(handler, options), "f");
            }
            else {
                tslib_1.__classPrivateFieldSet(this, _FlashServer_servePromise, serve(handler, options), "f");
            }
        };
        tslib_1.__classPrivateFieldSet(this, _FlashServer_stream, new dntShim.ReadableStream({ start }), "f");
        return p;
    }
    [(_FlashServer_app = new WeakMap(), _FlashServer_closed = new WeakMap(), _FlashServer_controller = new WeakMap(), _FlashServer_abortController = new WeakMap(), _FlashServer_options = new WeakMap(), _FlashServer_servePromise = new WeakMap(), _FlashServer_stream = new WeakMap(), Symbol.asyncIterator)]() {
        (0, util_js_1.assert)(tslib_1.__classPrivateFieldGet(this, _FlashServer_stream, "f"), ".listen() was not called before iterating or server is closed.");
        return tslib_1.__classPrivateFieldGet(this, _FlashServer_stream, "f")[Symbol.asyncIterator]();
    }
}
exports.FlashServer = FlashServer;
