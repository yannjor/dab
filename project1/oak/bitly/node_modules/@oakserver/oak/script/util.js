"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sign = exports.importKey = exports.isNode = exports.encodeBase64Safe = exports.Uint8ArrayTransformStream = exports.resolvePath = exports.stripEol = exports.skipLWSPChar = exports.isHtml = exports.isRedirectStatus = exports.isErrorStatus = exports.readableStreamFromReader = exports.readableStreamFromAsyncIterable = exports.isListenTlsOptions = exports.isConn = exports.isReader = exports.isRouterContext = exports.isAsyncIterable = exports.getBoundary = exports.getRandomFilename = exports.encodeUrl = exports.decodeComponent = exports.assert = exports.BODY_TYPES = exports.DEFAULT_CHUNK_SIZE = void 0;
const tslib_1 = require("tslib");
// Copyright 2018-2022 the oak authors. All rights reserved. MIT license.
const dntShim = tslib_1.__importStar(require("./_dnt.shims.js"));
const deps_js_1 = require("./deps.js");
const ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
const HTAB = "\t".charCodeAt(0);
const SPACE = " ".charCodeAt(0);
const CR = "\r".charCodeAt(0);
const LF = "\n".charCodeAt(0);
const UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
const UNMATCHED_SURROGATE_PAIR_REPLACE = "$1\uFFFD$2";
exports.DEFAULT_CHUNK_SIZE = 16640; // 17 Kib
/** Body types which will be coerced into strings before being sent. */
exports.BODY_TYPES = ["string", "number", "bigint", "boolean", "symbol"];
function assert(cond, msg = "Assertion failed") {
    if (!cond) {
        throw new Error(msg);
    }
}
exports.assert = assert;
/** Safely decode a URI component, where if it fails, instead of throwing,
 * just returns the original string
 */
function decodeComponent(text) {
    try {
        return decodeURIComponent(text);
    }
    catch {
        return text;
    }
}
exports.decodeComponent = decodeComponent;
/** Encodes the url preventing double enconding */
function encodeUrl(url) {
    return String(url)
        .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)
        .replace(ENCODE_CHARS_REGEXP, encodeURI);
}
exports.encodeUrl = encodeUrl;
function bufferToHex(buffer) {
    const arr = Array.from(new Uint8Array(buffer));
    return arr.map((b) => b.toString(16).padStart(2, "0")).join("");
}
async function getRandomFilename(prefix = "", extension = "") {
    const buffer = await dntShim.crypto.subtle.digest("SHA-1", dntShim.crypto.getRandomValues(new Uint8Array(256)));
    return `${prefix}${bufferToHex(buffer)}${extension ? `.${extension}` : ""}`;
}
exports.getRandomFilename = getRandomFilename;
async function getBoundary() {
    const buffer = await dntShim.crypto.subtle.digest("SHA-1", dntShim.crypto.getRandomValues(new Uint8Array(256)));
    return `oak_${bufferToHex(buffer)}`;
}
exports.getBoundary = getBoundary;
/** Guard for Async Iterables */
function isAsyncIterable(value) {
    return typeof value === "object" && value !== null &&
        Symbol.asyncIterator in value &&
        // deno-lint-ignore no-explicit-any
        typeof value[Symbol.asyncIterator] === "function";
}
exports.isAsyncIterable = isAsyncIterable;
function isRouterContext(value) {
    return "params" in value;
}
exports.isRouterContext = isRouterContext;
/** Guard for `Deno.Reader`. */
function isReader(value) {
    return typeof value === "object" && value !== null && "read" in value &&
        typeof value.read === "function";
}
exports.isReader = isReader;
function isCloser(value) {
    return typeof value === "object" && value != null && "close" in value &&
        // deno-lint-ignore no-explicit-any
        typeof value["close"] === "function";
}
function isConn(value) {
    return typeof value === "object" && value != null && "rid" in value &&
        // deno-lint-ignore no-explicit-any
        typeof value.rid === "number" && "localAddr" in value &&
        "remoteAddr" in value;
}
exports.isConn = isConn;
function isListenTlsOptions(value) {
    return typeof value === "object" && value !== null &&
        ("cert" in value || "certFile" in value) &&
        ("key" in value || "keyFile" in value) && "port" in value;
}
exports.isListenTlsOptions = isListenTlsOptions;
/**
 * Create a `ReadableStream<Uint8Array>` from an `AsyncIterable`.
 */
function readableStreamFromAsyncIterable(source) {
    return new dntShim.ReadableStream({
        async start(controller) {
            for await (const chunk of source) {
                if (exports.BODY_TYPES.includes(typeof chunk)) {
                    controller.enqueue(encoder.encode(String(chunk)));
                }
                else if (chunk instanceof Uint8Array) {
                    controller.enqueue(chunk);
                }
                else if (ArrayBuffer.isView(chunk)) {
                    controller.enqueue(new Uint8Array(chunk.buffer));
                }
                else if (chunk instanceof ArrayBuffer) {
                    controller.enqueue(new Uint8Array(chunk));
                }
                else {
                    try {
                        controller.enqueue(encoder.encode(JSON.stringify(chunk)));
                    }
                    catch {
                        // we just swallow errors here
                    }
                }
            }
            controller.close();
        },
    });
}
exports.readableStreamFromAsyncIterable = readableStreamFromAsyncIterable;
/**
 * Create a `ReadableStream<Uint8Array>` from a `Deno.Reader`.
 *
 * When the pull algorithm is called on the stream, a chunk from the reader
 * will be read.  When `null` is returned from the reader, the stream will be
 * closed along with the reader (if it is also a `Deno.Closer`).
 *
 * An example converting a `Deno.FsFile` into a readable stream:
 *
 * ```ts
 * import { readableStreamFromReader } from "https://deno.land/std/io/mod.ts";
 *
 * const file = await Deno.open("./file.txt", { read: true });
 * const fileStream = readableStreamFromReader(file);
 * ```
 */
function readableStreamFromReader(reader, options = {}) {
    const { autoClose = true, chunkSize = exports.DEFAULT_CHUNK_SIZE, strategy, } = options;
    return new dntShim.ReadableStream({
        async pull(controller) {
            const chunk = new Uint8Array(chunkSize);
            try {
                const read = await reader.read(chunk);
                if (read === null) {
                    if (isCloser(reader) && autoClose) {
                        reader.close();
                    }
                    controller.close();
                    return;
                }
                controller.enqueue(chunk.subarray(0, read));
            }
            catch (e) {
                controller.error(e);
                if (isCloser(reader)) {
                    reader.close();
                }
            }
        },
        cancel() {
            if (isCloser(reader) && autoClose) {
                reader.close();
            }
        },
    }, strategy);
}
exports.readableStreamFromReader = readableStreamFromReader;
/** Determines if a HTTP `Status` is an `ErrorStatus` (4XX or 5XX). */
function isErrorStatus(value) {
    return [
        deps_js_1.Status.BadRequest,
        deps_js_1.Status.Unauthorized,
        deps_js_1.Status.PaymentRequired,
        deps_js_1.Status.Forbidden,
        deps_js_1.Status.NotFound,
        deps_js_1.Status.MethodNotAllowed,
        deps_js_1.Status.NotAcceptable,
        deps_js_1.Status.ProxyAuthRequired,
        deps_js_1.Status.RequestTimeout,
        deps_js_1.Status.Conflict,
        deps_js_1.Status.Gone,
        deps_js_1.Status.LengthRequired,
        deps_js_1.Status.PreconditionFailed,
        deps_js_1.Status.RequestEntityTooLarge,
        deps_js_1.Status.RequestURITooLong,
        deps_js_1.Status.UnsupportedMediaType,
        deps_js_1.Status.RequestedRangeNotSatisfiable,
        deps_js_1.Status.ExpectationFailed,
        deps_js_1.Status.Teapot,
        deps_js_1.Status.MisdirectedRequest,
        deps_js_1.Status.UnprocessableEntity,
        deps_js_1.Status.Locked,
        deps_js_1.Status.FailedDependency,
        deps_js_1.Status.UpgradeRequired,
        deps_js_1.Status.PreconditionRequired,
        deps_js_1.Status.TooManyRequests,
        deps_js_1.Status.RequestHeaderFieldsTooLarge,
        deps_js_1.Status.UnavailableForLegalReasons,
        deps_js_1.Status.InternalServerError,
        deps_js_1.Status.NotImplemented,
        deps_js_1.Status.BadGateway,
        deps_js_1.Status.ServiceUnavailable,
        deps_js_1.Status.GatewayTimeout,
        deps_js_1.Status.HTTPVersionNotSupported,
        deps_js_1.Status.VariantAlsoNegotiates,
        deps_js_1.Status.InsufficientStorage,
        deps_js_1.Status.LoopDetected,
        deps_js_1.Status.NotExtended,
        deps_js_1.Status.NetworkAuthenticationRequired,
    ].includes(value);
}
exports.isErrorStatus = isErrorStatus;
/** Determines if a HTTP `Status` is a `RedirectStatus` (3XX). */
function isRedirectStatus(value) {
    return [
        deps_js_1.Status.MultipleChoices,
        deps_js_1.Status.MovedPermanently,
        deps_js_1.Status.Found,
        deps_js_1.Status.SeeOther,
        deps_js_1.Status.UseProxy,
        deps_js_1.Status.TemporaryRedirect,
        deps_js_1.Status.PermanentRedirect,
    ].includes(value);
}
exports.isRedirectStatus = isRedirectStatus;
/** Determines if a string "looks" like HTML */
function isHtml(value) {
    return /^\s*<(?:!DOCTYPE|html|body)/i.test(value);
}
exports.isHtml = isHtml;
/** Returns `u8` with leading white space removed. */
function skipLWSPChar(u8) {
    const result = new Uint8Array(u8.length);
    let j = 0;
    for (let i = 0; i < u8.length; i++) {
        if (u8[i] === SPACE || u8[i] === HTAB)
            continue;
        result[j++] = u8[i];
    }
    return result.slice(0, j);
}
exports.skipLWSPChar = skipLWSPChar;
function stripEol(value) {
    if (value[value.byteLength - 1] == LF) {
        let drop = 1;
        if (value.byteLength > 1 && value[value.byteLength - 2] === CR) {
            drop = 2;
        }
        return value.subarray(0, value.byteLength - drop);
    }
    return value;
}
exports.stripEol = stripEol;
/*!
 * Adapted directly from https://github.com/pillarjs/resolve-path
 * which is licensed as follows:
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Jonathan Ong <me@jongleberry.com>
 * Copyright (c) 2015-2018 Douglas Christopher Wilson <doug@somethingdoug.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
const UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
function resolvePath(rootPath, relativePath) {
    let path = relativePath;
    let root = rootPath;
    // root is optional, similar to root.resolve
    if (relativePath === undefined) {
        path = rootPath;
        root = ".";
    }
    if (path == null) {
        throw new TypeError("Argument relativePath is required.");
    }
    // containing NULL bytes is malicious
    if (path.includes("\0")) {
        throw (0, deps_js_1.createHttpError)(400, "Malicious Path");
    }
    // path should never be absolute
    if ((0, deps_js_1.isAbsolute)(path)) {
        throw (0, deps_js_1.createHttpError)(400, "Malicious Path");
    }
    // path outside root
    if (UP_PATH_REGEXP.test((0, deps_js_1.normalize)("." + deps_js_1.sep + path))) {
        throw (0, deps_js_1.createHttpError)(403);
    }
    // join the relative path
    return (0, deps_js_1.normalize)((0, deps_js_1.join)(root, path));
}
exports.resolvePath = resolvePath;
/** A utility class that transforms "any" chunk into an `Uint8Array`. */
class Uint8ArrayTransformStream extends dntShim.TransformStream {
    constructor() {
        const init = {
            async transform(chunk, controller) {
                chunk = await chunk;
                switch (typeof chunk) {
                    case "object":
                        if (chunk === null) {
                            controller.terminate();
                        }
                        else if (ArrayBuffer.isView(chunk)) {
                            controller.enqueue(new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength));
                        }
                        else if (Array.isArray(chunk) &&
                            chunk.every((value) => typeof value === "number")) {
                            controller.enqueue(new Uint8Array(chunk));
                        }
                        else if (typeof chunk.valueOf === "function" && chunk.valueOf() !== chunk) {
                            this.transform(chunk.valueOf(), controller);
                        }
                        else if ("toJSON" in chunk) {
                            this.transform(JSON.stringify(chunk), controller);
                        }
                        break;
                    case "symbol":
                        controller.error(new TypeError("Cannot transform a symbol to a Uint8Array"));
                        break;
                    case "undefined":
                        controller.error(new TypeError("Cannot transform undefined to a Uint8Array"));
                        break;
                    default:
                        controller.enqueue(this.encoder.encode(String(chunk)));
                }
            },
            encoder: new TextEncoder(),
        };
        super(init);
    }
}
exports.Uint8ArrayTransformStream = Uint8ArrayTransformStream;
const replacements = {
    "/": "_",
    "+": "-",
    "=": "",
};
const encoder = new TextEncoder();
function encodeBase64Safe(data) {
    return deps_js_1.base64.encode(data).replace(/\/|\+|=/g, (c) => replacements[c]);
}
exports.encodeBase64Safe = encodeBase64Safe;
function isNode() {
    return "process" in dntShim.dntGlobalThis && "global" in dntShim.dntGlobalThis;
}
exports.isNode = isNode;
function importKey(key) {
    if (typeof key === "string") {
        key = encoder.encode(key);
    }
    else if (Array.isArray(key)) {
        key = new Uint8Array(key);
    }
    return dntShim.crypto.subtle.importKey("raw", key, {
        name: "HMAC",
        hash: { name: "SHA-256" },
    }, true, ["sign", "verify"]);
}
exports.importKey = importKey;
function sign(data, key) {
    if (typeof data === "string") {
        data = encoder.encode(data);
    }
    else if (Array.isArray(data)) {
        data = Uint8Array.from(data);
    }
    return dntShim.crypto.subtle.sign("HMAC", key, data);
}
exports.sign = sign;
