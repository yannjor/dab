"use strict";
// Copyright 2018-2022 the oak authors. All rights reserved. MIT license.
var _Cookies_instances, _Cookies_cookieKeys, _Cookies_keys, _Cookies_request, _Cookies_response, _Cookies_secure, _Cookies_requestKeys;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cookies = void 0;
const tslib_1 = require("tslib");
const matchCache = {};
// deno-lint-ignore no-control-regex
const FIELD_CONTENT_REGEXP = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
const KEY_REGEXP = /(?:^|;) *([^=]*)=[^;]*/g;
const SAME_SITE_REGEXP = /^(?:lax|none|strict)$/i;
function getPattern(name) {
    if (name in matchCache) {
        return matchCache[name];
    }
    return matchCache[name] = new RegExp(`(?:^|;) *${name.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")}=([^;]*)`);
}
function pushCookie(headers, cookie) {
    if (cookie.overwrite) {
        for (let i = headers.length - 1; i >= 0; i--) {
            if (headers[i].indexOf(`${cookie.name}=`) === 0) {
                headers.splice(i, 1);
            }
        }
    }
    headers.push(cookie.toHeader());
}
function validateCookieProperty(key, value) {
    if (value && !FIELD_CONTENT_REGEXP.test(value)) {
        throw new TypeError(`The ${key} of the cookie (${value}) is invalid.`);
    }
}
class Cookie {
    /** A logical representation of a cookie, used to internally manage the
     * cookie instances. */
    constructor(name, value, attributes) {
        Object.defineProperty(this, "domain", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "expires", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "httpOnly", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "maxAge", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "overwrite", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "path", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "/"
        });
        Object.defineProperty(this, "sameSite", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "secure", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "signed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        validateCookieProperty("name", name);
        validateCookieProperty("value", value);
        this.name = name;
        this.value = value ?? "";
        Object.assign(this, attributes);
        if (!this.value) {
            this.expires = new Date(0);
            this.maxAge = undefined;
        }
        validateCookieProperty("path", this.path);
        validateCookieProperty("domain", this.domain);
        if (this.sameSite && typeof this.sameSite === "string" &&
            !SAME_SITE_REGEXP.test(this.sameSite)) {
            throw new TypeError(`The sameSite of the cookie ("${this.sameSite}") is invalid.`);
        }
    }
    toHeader() {
        let header = this.toString();
        if (this.maxAge) {
            this.expires = new Date(Date.now() + (this.maxAge * 1000));
        }
        if (this.path) {
            header += `; path=${this.path}`;
        }
        if (this.expires) {
            header += `; expires=${this.expires.toUTCString()}`;
        }
        if (this.domain) {
            header += `; domain=${this.domain}`;
        }
        if (this.sameSite) {
            header += `; samesite=${this.sameSite === true ? "strict" : this.sameSite.toLowerCase()}`;
        }
        if (this.secure) {
            header += "; secure";
        }
        if (this.httpOnly) {
            header += "; httponly";
        }
        return header;
    }
    toString() {
        return `${this.name}=${this.value}`;
    }
}
/** An interface which allows setting and accessing cookies related to both the
 * current request and response. Each {@linkcode Context} has a property
 * `.cookies` which is an instance of this class.
 *
 * Because oak supports automatic encryption, most methods (except `.delete`)
 * are asynchronous. This is because oak leverages the Web Crypto APIs, which
 * are asynchronous by nature.
 *
 * ### Example
 *
 * ```ts
 * import { Application } from "https://deno.land/x/oak/mod.ts";
 *
 * const app = new Application();
 *
 * app.use(async (ctx) => {
 *   for await (const cookie of ctx.cookies) {
 *     // iterating over each cookie
 *   }
 *   await ctx.cookie.set("myCookie", "a value"); // setting or updating a cookie
 *   const id = await ctx.cookie.get("my-id"); // getting a value of a cookie if present
 *   ctx.cookie.delete();
 * });
 * ```
 */
class Cookies {
    constructor(request, response, options = {}) {
        _Cookies_instances.add(this);
        _Cookies_cookieKeys.set(this, void 0);
        _Cookies_keys.set(this, void 0);
        _Cookies_request.set(this, void 0);
        _Cookies_response.set(this, void 0);
        _Cookies_secure.set(this, void 0);
        const { keys, secure } = options;
        tslib_1.__classPrivateFieldSet(this, _Cookies_keys, keys, "f");
        tslib_1.__classPrivateFieldSet(this, _Cookies_request, request, "f");
        tslib_1.__classPrivateFieldSet(this, _Cookies_response, response, "f");
        tslib_1.__classPrivateFieldSet(this, _Cookies_secure, secure, "f");
    }
    /** Set a cookie to be deleted in the response.  This is a "shortcut" to
     * `.set(name, null, options?)`. */
    delete(name, options = {}) {
        this.set(name, null, options);
        return true;
    }
    /** Iterate over the request's cookies, yielding up a tuple containing the
     * key and the value.
     *
     * If there are keys set on the application, only keys and values that are
     * properly signed will be returned. */
    async *entries() {
        const keys = tslib_1.__classPrivateFieldGet(this, _Cookies_instances, "m", _Cookies_requestKeys).call(this);
        for (const key of keys) {
            const value = await this.get(key);
            if (value) {
                yield [key, value];
            }
        }
    }
    async forEach(callback, 
    // deno-lint-ignore no-explicit-any
    thisArg = null) {
        const keys = tslib_1.__classPrivateFieldGet(this, _Cookies_instances, "m", _Cookies_requestKeys).call(this);
        for (const key of keys) {
            const value = await this.get(key);
            if (value) {
                callback.call(thisArg, key, value, this);
            }
        }
    }
    /** Get the value of a cookie from the request.
     *
     * If the cookie is signed, and the signature is invalid, the cookie will
     * be set to be deleted in the the response.  If the signature uses an "old"
     * key, the cookie will be re-signed with the current key and be added to the
     * response to be updated. */
    async get(name, options = {}) {
        const signed = options.signed ?? !!tslib_1.__classPrivateFieldGet(this, _Cookies_keys, "f");
        const nameSig = `${name}.sig`;
        const header = tslib_1.__classPrivateFieldGet(this, _Cookies_request, "f").headers.get("cookie");
        if (!header) {
            return;
        }
        const match = header.match(getPattern(name));
        if (!match) {
            return;
        }
        const [, value] = match;
        if (!signed) {
            return value;
        }
        const digest = await this.get(nameSig, { signed: false });
        if (!digest) {
            return;
        }
        const data = `${name}=${value}`;
        if (!tslib_1.__classPrivateFieldGet(this, _Cookies_keys, "f")) {
            throw new TypeError("keys required for signed cookies");
        }
        const index = await tslib_1.__classPrivateFieldGet(this, _Cookies_keys, "f").indexOf(data, digest);
        if (index < 0) {
            this.delete(nameSig, { path: "/", signed: false });
        }
        else {
            if (index) {
                // the key has "aged" and needs to be re-signed
                this.set(nameSig, await tslib_1.__classPrivateFieldGet(this, _Cookies_keys, "f").sign(data), { signed: false });
            }
            return value;
        }
    }
    /** Iterate over the request's cookies, yielding up the keys.
     *
     * If there are keys set on the application, only the keys that are properly
     * signed will be returned. */
    async *keys() {
        const keys = tslib_1.__classPrivateFieldGet(this, _Cookies_instances, "m", _Cookies_requestKeys).call(this);
        for (const key of keys) {
            const value = await this.get(key);
            if (value) {
                yield key;
            }
        }
    }
    /** Set a cookie in the response.
     *
     * If there are keys set in the application, cookies will be automatically
     * signed, unless overridden by the set options.  Cookies can be deleted by
     * setting the value to `null`. */
    async set(name, value, options = {}) {
        const request = tslib_1.__classPrivateFieldGet(this, _Cookies_request, "f");
        const response = tslib_1.__classPrivateFieldGet(this, _Cookies_response, "f");
        const headers = [];
        for (const [key, value] of response.headers.entries()) {
            if (key === "set-cookie") {
                headers.push(value);
            }
        }
        const secure = tslib_1.__classPrivateFieldGet(this, _Cookies_secure, "f") !== undefined ? tslib_1.__classPrivateFieldGet(this, _Cookies_secure, "f") : request.secure;
        const signed = options.signed ?? !!tslib_1.__classPrivateFieldGet(this, _Cookies_keys, "f");
        if (!secure && options.secure && !options.ignoreInsecure) {
            throw new TypeError("Cannot send secure cookie over unencrypted connection.");
        }
        const cookie = new Cookie(name, value, options);
        cookie.secure = options.secure ?? secure;
        pushCookie(headers, cookie);
        if (signed) {
            if (!tslib_1.__classPrivateFieldGet(this, _Cookies_keys, "f")) {
                throw new TypeError(".keys required for signed cookies.");
            }
            cookie.value = await tslib_1.__classPrivateFieldGet(this, _Cookies_keys, "f").sign(cookie.toString());
            cookie.name += ".sig";
            pushCookie(headers, cookie);
        }
        response.headers.delete("Set-Cookie");
        for (const header of headers) {
            response.headers.append("Set-Cookie", header);
        }
        return this;
    }
    /** Iterate over the request's cookies, yielding up each value.
     *
     * If there are keys set on the application, only the values that are
     * properly signed will be returned. */
    async *values() {
        const keys = tslib_1.__classPrivateFieldGet(this, _Cookies_instances, "m", _Cookies_requestKeys).call(this);
        for (const key of keys) {
            const value = await this.get(key);
            if (value) {
                yield value;
            }
        }
    }
    /** Iterate over the request's cookies, yielding up a tuple containing the
     * key and the value.
     *
     * If there are keys set on the application, only keys and values that are
     * properly signed will be returned. */
    async *[(_Cookies_cookieKeys = new WeakMap(), _Cookies_keys = new WeakMap(), _Cookies_request = new WeakMap(), _Cookies_response = new WeakMap(), _Cookies_secure = new WeakMap(), _Cookies_instances = new WeakSet(), _Cookies_requestKeys = function _Cookies_requestKeys() {
        if (tslib_1.__classPrivateFieldGet(this, _Cookies_cookieKeys, "f")) {
            return tslib_1.__classPrivateFieldGet(this, _Cookies_cookieKeys, "f");
        }
        const result = tslib_1.__classPrivateFieldSet(this, _Cookies_cookieKeys, [], "f");
        const header = tslib_1.__classPrivateFieldGet(this, _Cookies_request, "f").headers.get("cookie");
        if (!header) {
            return result;
        }
        let matches;
        while ((matches = KEY_REGEXP.exec(header))) {
            const [, key] = matches;
            result.push(key);
        }
        return result;
    }, Symbol.asyncIterator)]() {
        const keys = tslib_1.__classPrivateFieldGet(this, _Cookies_instances, "m", _Cookies_requestKeys).call(this);
        for (const key of keys) {
            const value = await this.get(key);
            if (value) {
                yield [key, value];
            }
        }
    }
    [Symbol.for("Deno.customInspect")]() {
        return `${this.constructor.name} []`;
    }
    [Symbol.for("nodejs.util.inspect.custom")](depth, 
    // deno-lint-ignore no-explicit-any
    options, inspect) {
        if (depth < 0) {
            return options.stylize(`[${this.constructor.name}]`, "special");
        }
        const newOptions = Object.assign({}, options, {
            depth: options.depth === null ? null : options.depth - 1,
        });
        return `${options.stylize(this.constructor.name, "special")} ${inspect([], newOptions)}`;
    }
}
exports.Cookies = Cookies;
