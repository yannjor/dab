import * as dntShim from "./_dnt.shims.js";
import type { Context } from "./context.js";
export interface ServerSentEventInit extends EventInit {
    /** An optional `id` which will be sent with the event and exposed in the
     * client `EventSource`. */
    id?: number;
    /** The replacer is passed to `JSON.stringify` when converting the `data`
     * property to a JSON string. */
    replacer?: (string | number)[] | ((this: any, key: string, value: any) => any);
    /** Space is passed to `JSON.stringify` when converting the `data` property
     * to a JSON string. */
    space?: string | number;
}
export interface ServerSentEventTargetOptions {
    /** Additional headers to send to the client during startup.  These headers
     * will overwrite any of the default headers if the key is duplicated. */
    headers?: dntShim.Headers;
    /** Keep client connections alive by sending a comment event to the client
     * at a specified interval.  If `true`, then it polls every 30000 milliseconds
     * (30 seconds). If set to a number, then it polls that number of
     * milliseconds.  The feature is disabled if set to `false`.  It defaults to
     * `false`. */
    keepAlive?: boolean | number;
}
declare class CloseEvent extends Event {
    constructor(eventInit: EventInit);
}
/** An event which contains information which will be sent to the remote
 * connection and be made available in an `EventSource` as an event. A server
 * creates new events and dispatches them on the target which will then be
 * sent to a client.
 *
 * See more about Server-sent events on [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events)
 *
 * ### Example
 *
 * ```ts
 * import { Application, ServerSentEvent } from "https://deno.land/x/oak/mod.ts";
 *
 * const app = new Application();
 *
 * app.use((ctx) => {
 *   const target = ctx.sendEvents();
 *   const evt = new ServerSentEvent(
 *     "message",
 *     { hello: "world" },
 *     { id: 1 },
 *   );
 *   target.dispatchEvent(evt);
 * });
 * ```
 */
export declare class ServerSentEvent extends Event {
    #private;
    /**
     * @param type the event type that will be available on the client. The type
     *             of `"message"` will be handled specifically as a message
     *             server-side event.
     * @param data  arbitrary data to send to the client, data this is a string
     *              will be sent unmodified, otherwise `JSON.parse()` will be used
     *              to serialize the value
     * @param eventInit initialization options for the event
     */
    constructor(type: string, data: unknown, eventInit?: ServerSentEventInit);
    /** The data associated with the event, which will be sent to the client and
     * be made available in the `EventSource`. */
    get data(): string;
    /** The optional ID associated with the event that will be sent to the client
     * and be made available in the `EventSource`. */
    get id(): number | undefined;
    toString(): string;
}
export interface ServerSentEventTarget extends EventTarget {
    /** Is set to `true` if events cannot be sent to the remote connection.
     * Otherwise it is set to `false`.
     *
     * *Note*: This flag is lazily set, and might not reflect a closed state until
     * another event, comment or message is attempted to be processed. */
    readonly closed: boolean;
    /** Close the target, refusing to accept any more events. */
    close(): Promise<void>;
    /** Send a comment to the remote connection.  Comments are not exposed to the
     * client `EventSource` but are used for diagnostics and helping ensure a
     * connection is kept alive.
     *
     * ```ts
     * import { Application } from "https://deno.land/x/oak/mod.ts";
     *
     * const app = new Application();
     *
     * app.use((ctx) => {
     *    const sse = ctx.getSSETarget();
     *    sse.dispatchComment("this is a comment");
     * });
     *
     * await app.listen();
     * ```
     */
    dispatchComment(comment: string): boolean;
    /** Dispatch a message to the client.  This message will contain `data: ` only
     * and be available on the client `EventSource` on the `onmessage` or an event
     * listener of type `"message"`. */
    dispatchMessage(data: unknown): boolean;
    /** Dispatch a server sent event to the client.  The event `type` will be
     * sent as `event: ` to the client which will be raised as a `MessageEvent`
     * on the `EventSource` in the client.
     *
     * Any local event handlers will be dispatched to first, and if the event
     * is cancelled, it will not be sent to the client.
     *
     * ```ts
     * import { Application, ServerSentEvent } from "https://deno.land/x/oak/mod.ts";
     *
     * const app = new Application();
     *
     * app.use((ctx) => {
     *    const sse = ctx.getSSETarget();
     *    const evt = new ServerSentEvent("ping", "hello");
     *    sse.dispatchEvent(evt);
     * });
     *
     * await app.listen();
     * ```
     */
    dispatchEvent(event: ServerSentEvent): boolean;
    /** Dispatch a server sent event to the client.  The event `type` will be
     * sent as `event: ` to the client which will be raised as a `MessageEvent`
     * on the `EventSource` in the client.
     *
     * Any local event handlers will be dispatched to first, and if the event
     * is cancelled, it will not be sent to the client.
     *
     * ```ts
     * import { Application, ServerSentEvent } from "https://deno.land/x/oak/mod.ts";
     *
     * const app = new Application();
     *
     * app.use((ctx) => {
     *    const sse = ctx.getSSETarget();
     *    const evt = new ServerSentEvent("ping", "hello");
     *    sse.dispatchEvent(evt);
     * });
     *
     * await app.listen();
     * ```
     */
    dispatchEvent(event: CloseEvent | dntShim.ErrorEvent): boolean;
}
export declare class SSEStreamTarget extends EventTarget implements ServerSentEventTarget {
    #private;
    get closed(): boolean;
    constructor(context: Context, { headers, keepAlive }?: ServerSentEventTargetOptions);
    close(): Promise<void>;
    dispatchComment(comment: string): boolean;
    dispatchMessage(data: any): boolean;
    dispatchEvent(event: ServerSentEvent): boolean;
    dispatchEvent(event: CloseEvent | dntShim.ErrorEvent): boolean;
}
export {};
