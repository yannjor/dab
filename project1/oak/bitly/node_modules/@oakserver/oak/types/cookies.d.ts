import type { KeyStack } from "./keyStack.js";
import type { Request } from "./request.js";
import type { Response } from "./response.js";
export interface CookiesOptions {
    keys?: KeyStack;
    secure?: boolean;
}
export interface CookiesGetOptions {
    signed?: boolean;
}
export interface CookiesSetDeleteOptions {
    domain?: string;
    expires?: Date;
    httpOnly?: boolean;
    /** For use in situations where requests are presented to Deno as "insecure"
     * but are otherwise secure and so secure cookies can be treated as secure. */
    ignoreInsecure?: boolean;
    maxAge?: number;
    overwrite?: boolean;
    path?: string;
    secure?: boolean;
    sameSite?: "strict" | "lax" | "none" | boolean;
    signed?: boolean;
}
/** An interface which allows setting and accessing cookies related to both the
 * current request and response. Each {@linkcode Context} has a property
 * `.cookies` which is an instance of this class.
 *
 * Because oak supports automatic encryption, most methods (except `.delete`)
 * are asynchronous. This is because oak leverages the Web Crypto APIs, which
 * are asynchronous by nature.
 *
 * ### Example
 *
 * ```ts
 * import { Application } from "https://deno.land/x/oak/mod.ts";
 *
 * const app = new Application();
 *
 * app.use(async (ctx) => {
 *   for await (const cookie of ctx.cookies) {
 *     // iterating over each cookie
 *   }
 *   await ctx.cookie.set("myCookie", "a value"); // setting or updating a cookie
 *   const id = await ctx.cookie.get("my-id"); // getting a value of a cookie if present
 *   ctx.cookie.delete();
 * });
 * ```
 */
export declare class Cookies {
    #private;
    constructor(request: Request, response: Response, options?: CookiesOptions);
    /** Set a cookie to be deleted in the response.  This is a "shortcut" to
     * `.set(name, null, options?)`. */
    delete(name: string, options?: CookiesSetDeleteOptions): boolean;
    /** Iterate over the request's cookies, yielding up a tuple containing the
     * key and the value.
     *
     * If there are keys set on the application, only keys and values that are
     * properly signed will be returned. */
    entries(): AsyncIterableIterator<[string, string]>;
    forEach(callback: (key: string, value: string, cookies: this) => void, thisArg?: any): Promise<void>;
    /** Get the value of a cookie from the request.
     *
     * If the cookie is signed, and the signature is invalid, the cookie will
     * be set to be deleted in the the response.  If the signature uses an "old"
     * key, the cookie will be re-signed with the current key and be added to the
     * response to be updated. */
    get(name: string, options?: CookiesGetOptions): Promise<string | undefined>;
    /** Iterate over the request's cookies, yielding up the keys.
     *
     * If there are keys set on the application, only the keys that are properly
     * signed will be returned. */
    keys(): AsyncIterableIterator<string>;
    /** Set a cookie in the response.
     *
     * If there are keys set in the application, cookies will be automatically
     * signed, unless overridden by the set options.  Cookies can be deleted by
     * setting the value to `null`. */
    set(name: string, value: string | null, options?: CookiesSetDeleteOptions): Promise<this>;
    /** Iterate over the request's cookies, yielding up each value.
     *
     * If there are keys set on the application, only the values that are
     * properly signed will be returned. */
    values(): AsyncIterableIterator<string>;
    /** Iterate over the request's cookies, yielding up a tuple containing the
     * key and the value.
     *
     * If there are keys set on the application, only keys and values that are
     * properly signed will be returned. */
    [Symbol.asyncIterator](): AsyncIterableIterator<[string, string]>;
}
